# 작업 상태 모니터링 프로그램 개발 기획서 (Electron)

## 1. 프로젝트 개요

### 1.1 프로그램 정보
- **프로그램명**: WorkTimer (가칭)
- **목적**: 작업자의 실시간 작업 상태를 시각적으로 표시하여 동기부여 및 시간 관리 지원
- **개발 플랫폼**: Electron
- **지원 OS**: Windows 10/11, macOS 11+
- **개발 언어**: JavaScript/TypeScript, HTML, CSS
- **UI Framework**: React + TypeScript

### 1.2 핵심 가치
- 직관적인 시각적 피드백 (캐릭터 이미지)
- 자동 상태 감지로 수동 입력 최소화
- 비침투적 오버레이 UI
- 프라이버시 보호 (로컬 저장)

---

## 2. 기술 스택

### 2.1 프론트엔드
```
- Framework: React 18+
- Language: TypeScript
- Styling: Tailwind CSS
- State Management: Zustand (경량)
- Chart: Recharts
- Build: Vite
```

### 2.2 백엔드 (Electron Main Process)
```
- Runtime: Node.js
- Data Storage: electron-store (JSON 기반)
- File System: Node.js fs
- Process Monitoring: active-win
- System Events: electron powerMonitor
```

### 2.3 개발 도구
```
- Package Manager: npm/pnpm
- Bundler: electron-builder
- Dev Tool: electron-vite
- Linter: ESLint + Prettier
- Version Control: Git
```

### 2.4 주요 패키지
```json
{
  "dependencies": {
    "electron": "^28.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "zustand": "^4.4.0",
    "electron-store": "^8.1.0",
    "active-win": "^8.0.0",
    "recharts": "^2.10.0"
  },
  "devDependencies": {
    "electron-builder": "^24.0.0",
    "electron-vite": "^2.0.0",
    "typescript": "^5.0.0",
    "tailwindcss": "^3.4.0"
  }
}
```

---

## 3. 아키텍처 설계

### 3.1 Electron 프로세스 구조

```
┌─────────────────────────────────────────┐
│          Main Process (Node.js)         │
│  - 프로그램 감지                         │
│  - 시스템 이벤트 처리                    │
│  - JSON 파일 저장 (electron-store)      │
│  - IPC 통신 관리                         │
└──────────────┬──────────────────────────┘
               │ IPC
       ┌───────┴───────┬─────────────┐
       │               │             │
┌──────▼──────┐ ┌─────▼─────┐ ┌────▼────┐
│  Overlay    │ │ Dashboard │ │  Tray   │
│  Window     │ │  Window   │ │  Icon   │
│ (Renderer)  │ │(Renderer) │ │         │
└─────────────┘ └───────────┘ └─────────┘
```

### 3.2 디렉토리 구조

```
work-timer/
├── src/
│   ├── main/                 # Main Process
│   │   ├── index.ts          # 진입점
│   │   ├── window-manager.ts # 윈도우 관리
│   │   ├── tray-manager.ts   # 트레이 관리
│   │   ├── monitor/          # 모니터링
│   │   │   ├── process-monitor.ts
│   │   │   ├── idle-detector.ts
│   │   │   └── state-manager.ts
│   │   └── store/            # 데이터 저장
│   │       └── data-manager.ts
│   │
│   ├── renderer/             # Renderer Process
│   │   ├── overlay/          # 오버레이 윈도우
│   │   │   ├── App.tsx
│   │   │   ├── Timer.tsx
│   │   │   └── Character.tsx
│   │   ├── dashboard/        # 대시보드
│   │   │   ├── App.tsx
│   │   │   ├── ProjectList.tsx
│   │   │   ├── Statistics.tsx
│   │   │   └── Settings.tsx
│   │   ├── store/            # 상태 관리
│   │   │   └── useStore.ts
│   │   └── types/            # 타입 정의
│   │       └── index.ts
│   │
│   └── preload/              # Preload Scripts
│       └── index.ts          # IPC 브릿지
│
├── resources/                # 리소스
│   ├── icons/
│   └── default-images/
│
├── electron-builder.json     # 빌드 설정
├── package.json
└── tsconfig.json
```

### 3.3 데이터 저장 구조 (electron-store)

**Main Process: store/data-manager.ts**
```typescript
import Store from 'electron-store';

interface Project {
  id: string;
  name: string;
  color: string;
  programs: string[]; // 프로그램명 배열
  dailyGoal: number; // 초 단위
  createdAt: string;
}

interface WorkLog {
  id: string;
  projectId: string | null;
  state: WorkState;
  programName: string;
  startTime: string;
  endTime: string;
  duration: number; // 초 단위
}

interface Settings {
  restingThreshold: number; // 분
  sleepingThreshold: number; // 분
  overlayTransparency: number; // 0-100
  overlaySize: number; // 0-200
  textSize: number;
  autoStart: boolean;
  notifications: boolean;
}

interface StoreSchema {
  projects: Project[];
  workLogs: WorkLog[];
  settings: Settings;
  stateImages: Record<WorkState, string>; // 상태별 이미지 경로
  currentProject: string | null;
}

class DataManager {
  private store: Store<StoreSchema>;
  
  constructor() {
    this.store = new Store({
      defaults: {
        projects: [],
        workLogs: [],
        settings: {
          restingThreshold: 5,
          sleepingThreshold: 30,
          overlayTransparency: 90,
          overlaySize: 100,
          textSize: 14,
          autoStart: false,
          notifications: true
        },
        stateImages: {
          working: '',
          distracted: '',
          resting: '',
          eating: '',
          sleeping: ''
        },
        currentProject: null
      }
    });
  }
  
  // 프로젝트 관리
  getProjects(): Project[] {
    return this.store.get('projects');
  }
  
  addProject(project: Omit<Project, 'id' | 'createdAt'>): Project {
    const newProject: Project = {
      ...project,
      id: Date.now().toString(),
      createdAt: new Date().toISOString()
    };
    
    const projects = this.store.get('projects');
    projects.push(newProject);
    this.store.set('projects', projects);
    
    return newProject;
  }
  
  updateProject(id: string, updates: Partial<Project>): void {
    const projects = this.store.get('projects');
    const index = projects.findIndex(p => p.id === id);
    if (index !== -1) {
      projects[index] = { ...projects[index], ...updates };
      this.store.set('projects', projects);
    }
  }
  
  deleteProject(id: string): void {
    const projects = this.store.get('projects')
      .filter(p => p.id !== id);
    this.store.set('projects', projects);
  }
  
  // 작업 로그 관리
  addWorkLog(log: Omit<WorkLog, 'id'>): void {
    const workLogs = this.store.get('workLogs');
    workLogs.push({
      ...log,
      id: Date.now().toString()
    });
    
    // 최근 30일 데이터만 유지 (메모리 절약)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    
    const filtered = workLogs.filter(log => 
      new Date(log.startTime) > thirtyDaysAgo
    );
    
    this.store.set('workLogs', filtered);
  }
  
  getWorkLogs(startDate: Date, endDate: Date): WorkLog[] {
    return this.store.get('workLogs').filter(log => {
      const logDate = new Date(log.startTime);
      return logDate >= startDate && logDate <= endDate;
    });
  }
  
  // 설정 관리
  getSettings(): Settings {
    return this.store.get('settings');
  }
  
  updateSettings(updates: Partial<Settings>): void {
    const settings = this.store.get('settings');
    this.store.set('settings', { ...settings, ...updates });
  }
  
  // 이미지 경로 관리
  getStateImage(state: WorkState): string {
    return this.store.get(`stateImages.${state}`);
  }
  
  setStateImage(state: WorkState, imagePath: string): void {
    this.store.set(`stateImages.${state}`, imagePath);
  }
  
  // 통계 계산
  getTodayStats(): {
    workTime: number;
    distractedTime: number;
    restTime: number;
  } {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    const logs = this.getWorkLogs(today, new Date());
    
    return {
      workTime: logs
        .filter(l => l.state === 'working')
        .reduce((sum, l) => sum + l.duration, 0),
      distractedTime: logs
        .filter(l => l.state === 'distracted')
        .reduce((sum, l) => sum + l.duration, 0),
      restTime: logs
        .filter(l => ['resting', 'eating', 'sleeping'].includes(l.state))
        .reduce((sum, l) => sum + l.duration, 0)
    };
  }
}

export default new DataManager();
```

**데이터 파일 위치**
- Windows: `%APPDATA%/work-timer/config.json`
- macOS: `~/Library/Application Support/work-timer/config.json`
- 사용자가 프로그램 삭제 시 자동으로 제거됨

---

## 4. 핵심 기능 상세 설계

### 4.1 프로그램 감지 시스템

**Main Process: process-monitor.ts**
```typescript
interface ActiveProgram {
  name: string;
  title: string;
  bundleId?: string; // macOS
}

class ProcessMonitor {
  private interval: NodeJS.Timeout;
  private lastProgram: string = '';
  
  async start() {
    this.interval = setInterval(async () => {
      const active = await activeWin();
      if (active && active.owner.name !== this.lastProgram) {
        this.lastProgram = active.owner.name;
        this.notifyStateChange(active.owner.name);
      }
    }, 500);
  }
  
  private notifyStateChange(programName: string) {
    // IPC로 Renderer에 전송
    mainWindow.webContents.send('program-changed', programName);
  }
}
```

### 4.2 상태 관리 시스템

**Main Process: state-manager.ts**
```typescript
enum WorkState {
  WORKING = 'working',
  DISTRACTED = 'distracted',
  RESTING = 'resting',
  EATING = 'eating',
  SLEEPING = 'sleeping'
}

class StateManager {
  private currentState: WorkState = WorkState.WORKING;
  private currentProject: number | null = null;
  private sessionStartTime: Date = new Date();
  private lastInputTime: Date = new Date();
  
  // 임계값 (분)
  private restingThreshold = 5;
  private sleepingThreshold = 30;
  
  updateState(programName: string, projects: Project[]) {
    // 프로그램이 프로젝트에 매핑되어 있는지 확인
    const project = this.findProjectByProgram(programName, projects);
    
    if (project) {
      this.setState(WorkState.WORKING, project.id);
    } else {
      this.setState(WorkState.DISTRACTED, null);
    }
  }
  
  checkIdleTime() {
    const idleMinutes = (Date.now() - this.lastInputTime.getTime()) / 60000;
    
    if (idleMinutes >= this.sleepingThreshold) {
      this.setState(WorkState.SLEEPING, null);
    } else if (idleMinutes >= this.restingThreshold) {
      this.setState(WorkState.RESTING, null);
    }
  }
  
  toggleEating() {
    if (this.currentState === WorkState.EATING) {
      // 이전 상태로 복귀
      this.restorePreviousState();
    } else {
      this.setState(WorkState.EATING, null);
    }
  }
}
```

### 4.3 타이머 로직

**Renderer: useTimer.ts (React Hook)**
```typescript
interface TimerState {
  currentSessionTime: number; // 초
  todayTotalTime: number; // 초
}

function useTimer(state: WorkState) {
  const [sessionTime, setSessionTime] = useState(0);
  const [totalTime, setTotalTime] = useState(0);
  
  useEffect(() => {
    const timer = setInterval(() => {
      // 현재 세션 시간 증가
      setSessionTime(prev => prev + 1);
      
      // 작업중일 때만 누적 시간 증가
      if (state === WorkState.WORKING) {
        setTotalTime(prev => prev + 1);
      }
    }, 1000);
    
    return () => clearInterval(timer);
  }, [state]);
  
  // 상태 변경 시 세션 시간 리셋
  useEffect(() => {
    setSessionTime(0);
  }, [state]);
  
  // 자정에 누적 시간 리셋
  useEffect(() => {
    const checkMidnight = setInterval(() => {
      const now = new Date();
      if (now.getHours() === 0 && now.getMinutes() === 0) {
        setTotalTime(0);
      }
    }, 60000);
    
    return () => clearInterval(checkMidnight);
  }, []);
  
  return { sessionTime, totalTime };
}
```

### 4.4 오버레이 윈도우

**Main Process: overlay-window.ts**
```typescript
function createOverlayWindow() {
  const overlayWindow = new BrowserWindow({
    width: 250,
    height: 400,
    transparent: true,
    frame: false,
    alwaysOnTop: true,
    resizable: false,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.js')
    }
  });
  
  // 클릭 통과 모드
  overlayWindow.setIgnoreMouseEvents(false);
  
  // 화면 밖으로 나가지 않도록
  overlayWindow.on('move', () => {
    const bounds = overlayWindow.getBounds();
    const display = screen.getDisplayNearestPoint({
      x: bounds.x,
      y: bounds.y
    });
    
    // 경계 체크 및 조정
    if (bounds.x < display.bounds.x) {
      overlayWindow.setPosition(display.bounds.x, bounds.y);
    }
    // ... 나머지 경계 체크
  });
  
  return overlayWindow;
}
```

**Renderer: Overlay/App.tsx**
```typescript
function OverlayApp() {
  const { state, sessionTime, totalTime } = useStore();
  const [imageUrl, setImageUrl] = useState('');
  
  useEffect(() => {
    // IPC로 상태별 이미지 경로 요청
    window.electron.getStateImage(state).then(setImageUrl);
  }, [state]);
  
  return (
    <div className="overlay-container">
      <div className="timer-section">
        <div className="timer-label">현재 작업 시간</div>
        <div className="timer-value">
          {formatTime(sessionTime)}
        </div>
      </div>
      
      <div className="divider" />
      
      <div className="timer-section">
        <div className="timer-label">누적 작업 시간</div>
        <div className="timer-value">
          {formatTime(totalTime)}
        </div>
      </div>
      
      <div className="divider" />
      
      <div className="character-section">
        <img 
          src={imageUrl} 
          alt={state}
          className="character-image"
        />
      </div>
    </div>
  );
}
```

### 4.5 IPC 통신 구조

**Preload Script: preload/index.ts**
```typescript
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electron', {
  // 상태 관련
  onStateChange: (callback: (state: WorkState) => void) => {
    ipcRenderer.on('state-changed', (_, state) => callback(state));
  },
  
  // 프로젝트 관련
  getProjects: () => ipcRenderer.invoke('get-projects'),
  createProject: (project: Project) => 
    ipcRenderer.invoke('create-project', project),
  
  // 이미지 관련
  getStateImage: (state: WorkState) => 
    ipcRenderer.invoke('get-state-image', state),
  setStateImage: (state: WorkState, imagePath: string) =>
    ipcRenderer.invoke('set-state-image', state, imagePath),
  
  // 설정 관련
  getSettings: () => ipcRenderer.invoke('get-settings'),
  updateSettings: (settings: Settings) =>
    ipcRenderer.invoke('update-settings', settings),
  
  // 통계 관련
  getStatistics: (startDate: Date, endDate: Date) =>
    ipcRenderer.invoke('get-statistics', startDate, endDate),
  
  // 시스템 관련
  toggleEating: () => ipcRenderer.invoke('toggle-eating'),
  openDashboard: () => ipcRenderer.invoke('open-dashboard'),
  quit: () => ipcRenderer.invoke('quit-app')
});
```

---

## 5. UI 컴포넌트 설계

### 5.1 오버레이 스타일 (Tailwind CSS)

```typescript
// Overlay/App.tsx
export default function OverlayApp() {
  return (
    <div className="
      w-[250px] h-auto
      bg-white/90 backdrop-blur-sm
      rounded-2xl shadow-2xl
      border border-gray-200
    ">
      {/* 현재 작업 시간 */}
      <div className="p-4 text-center">
        <div className="text-xs text-gray-500 mb-1">
          현재 작업 시간
        </div>
        <div className="text-2xl font-bold text-gray-800">
          {formatTime(sessionTime)}
        </div>
      </div>
      
      {/* 구분선 */}
      <div className="h-px bg-gray-200 mx-4" />
      
      {/* 누적 작업 시간 */}
      <div className="p-4 text-center">
        <div className="text-xs text-gray-500 mb-1">
          누적 작업 시간
        </div>
        <div className="text-2xl font-bold text-blue-600">
          {formatTime(totalTime)}
        </div>
      </div>
      
      {/* 구분선 */}
      <div className="h-px bg-gray-200 mx-4" />
      
      {/* 캐릭터 이미지 */}
      <div className="p-6 flex justify-center">
        <img 
          src={imageUrl}
          alt={state}
          className="w-40 h-40 object-contain"
        />
      </div>
    </div>
  );
}
```

### 5.2 대시보드 레이아웃

```typescript
// Dashboard/App.tsx
export default function DashboardApp() {
  return (
    <div className="h-screen flex">
      {/* 사이드바 */}
      <aside className="w-64 bg-gray-50 border-r">
        <nav className="p-4 space-y-2">
          <NavItem icon="📊" label="대시보드" />
          <NavItem icon="📁" label="프로젝트" />
          <NavItem icon="📈" label="통계" />
          <NavItem icon="⚙️" label="설정" />
        </nav>
      </aside>
      
      {/* 메인 컨텐츠 */}
      <main className="flex-1 overflow-auto">
        <Outlet />
      </main>
    </div>
  );
}
```

---

## 6. 개발 단계별 계획

### Phase 1: 기본 구조 구축 (1주)
**목표**: Electron 프로젝트 세팅 및 기본 윈도우 생성

**작업 내용**
- [ ] Electron + React + TypeScript 보일러플레이트 구성
- [ ] 오버레이 윈도우 생성
- [ ] 대시보드 윈도우 생성
- [ ] IPC 통신 기본 구조
- [ ] 트레이 아이콘 구현

**완료 기준**
- 두 개의 윈도우가 정상적으로 열림
- IPC로 메시지 송수신 가능
- 트레이 메뉴에서 윈도우 열기/닫기 가능

---

### Phase 2: 프로그램 감지 (1주)
**목표**: 활성 프로그램 감지 및 상태 전환

**작업 내용**
- [ ] active-win 패키지 통합
- [ ] 프로그램 감지 주기 설정 (0.5초)
- [ ] 감지된 프로그램명 로깅
- [ ] 상태 전환 로직 구현
- [ ] Idle 시간 감지

**완료 기준**
- 현재 활성 프로그램명이 콘솔에 출력됨
- 5분 idle 시 "쉬는 중" 상태로 전환
- 30분 idle 시 "자는 중" 상태로 전환

---

### Phase 3: 데이터 저장 (3일)
**목표**: electron-store로 데이터 저장/불러오기

**작업 내용**
- [ ] electron-store 설정
- [ ] 데이터 구조 정의 (TypeScript 인터페이스)
- [ ] 프로젝트 CRUD 함수
- [ ] 작업 로그 저장 로직
- [ ] 설정 저장/불러오기

**완료 기준**
- 프로젝트 생성/수정/삭제 가능
- 작업 로그가 JSON 파일에 저장됨
- 앱 재시작 후 데이터 유지
- 30일 이상 된 로그 자동 삭제

---

### Phase 4: 타이머 로직 (3일)
**목표**: 실시간 타이머 및 시간 누적

**작업 내용**
- [ ] 세션 타이머 구현
- [ ] 누적 시간 계산
- [ ] 자정 초기화 로직
- [ ] 상태 변경 시 세션 리셋
- [ ] HH:mm:ss 포맷팅

**완료 기준**
- 타이머가 1초마다 정확히 증가
- 상태 변경 시 세션 타이머 리셋
- 자정에 누적 시간 초기화

---

### Phase 5: 오버레이 UI (1주)
**목표**: 오버레이 윈도우 디자인 및 기능

**작업 내용**
- [ ] Tailwind CSS 스타일링
- [ ] 타이머 표시 컴포넌트
- [ ] 이미지 로드 및 표시
- [ ] 드래그로 위치 이동
- [ ] 우클릭 컨텍스트 메뉴
- [ ] 더블클릭 시 대시보드 열기

**완료 기준**
- 디자인된 오버레이가 표시됨
- 드래그로 위치 변경 가능
- 우클릭 메뉴 동작
- 이미지가 상태별로 변경됨

---

### Phase 6: 프로젝트 관리 UI (1주)
**목표**: 대시보드에서 프로젝트 관리

**작업 내용**
- [ ] 프로젝트 리스트 컴포넌트
- [ ] 프로젝트 생성 폼
- [ ] 프로그램 매핑 UI
- [ ] 프로젝트 수정/삭제
- [ ] 프로그램 자동 감지 및 선택

**완료 기준**
- 프로젝트 CRUD가 UI에서 가능
- 프로그램 선택 시 매핑 저장
- 리스트가 실시간 업데이트

---

### Phase 7: 통계 기능 (1주)
**목표**: 작업 통계 조회 및 시각화

**작업 내용**
- [ ] 일별/주별/월별 통계 쿼리
- [ ] Recharts 차트 구현
- [ ] 프로젝트별 시간 분포
- [ ] 상태별 시간 비율
- [ ] 날짜 범위 선택

**완료 기준**
- 일별 작업 시간 차트 표시
- 프로젝트별 파이 차트 표시
- 날짜 선택 시 데이터 업데이트

---

### Phase 8: 설정 기능 (3일)
**목표**: 사용자 설정 UI 및 로직

**작업 내용**
- [ ] 시간 임계값 설정
- [ ] 상태별 이미지 업로드
- [ ] 오버레이 스타일 설정
- [ ] 알림 설정
- [ ] 자동 시작 설정

**완료 기준**
- 모든 설정이 UI에서 변경 가능
- 설정 변경 즉시 적용
- 재시작 후에도 설정 유지

---

### Phase 9: 테스트 및 최적화 (1주)
**목표**: 버그 수정 및 성능 최적화

**작업 내용**
- [ ] 메모리 누수 체크
- [ ] CPU 사용률 최적화
- [ ] 멀티 모니터 테스트
- [ ] 장시간 실행 안정성 테스트
- [ ] 예외 처리 강화

**완료 기준**
- 메모리 사용량 100MB 이하
- CPU 사용률 1% 이하
- 24시간 연속 실행 가능

---

### Phase 10: 빌드 및 배포 (3일)
**목표**: 설치 파일 생성 및 배포 준비

**작업 내용**
- [ ] electron-builder 설정
- [ ] Windows 설치 파일 생성
- [ ] macOS 앱 번들 생성
- [ ] 아이콘 및 리소스 포함
- [ ] 자동 업데이트 설정 (선택)

**완료 기준**
- .exe 파일 생성 (Windows)
- .dmg 파일 생성 (macOS)
- 설치 및 실행 정상 작동

---

## 7. 예상 개발 기간

**총 개발 기간**: 6~8주

### 주차별 계획
- **1주차**: 프로젝트 세팅 + 프로그램 감지
- **2주차**: 데이터 저장 + 타이머 로직
- **3주차**: 오버레이 UI
- **4주차**: 대시보드 - 프로젝트 관리
- **5주차**: 대시보드 - 통계 + 설정
- **6주차**: 테스트 및 최적화
- **7주차**: 추가 기능 (선택)
- **8주차**: 빌드 및 배포

---

## 8. 개발 시 주의사항

### 8.1 Electron 보안
- `nodeIntegration: false` 필수
- `contextIsolation: true` 필수
- Preload 스크립트를 통한 안전한 IPC 통신
- 외부 URL 로드 금지

### 8.2 성능 최적화
- 프로그램 감지 주기 적절히 설정 (0.5~1초)
- 이미지 캐싱으로 메모리 절약
- 불필요한 re-render 방지 (React.memo, useMemo)
- 작업 로그 30일 자동 정리로 JSON 파일 크기 관리

### 8.3 크로스 플랫폼 대응
- 파일 경로는 path 모듈 사용
- OS별 프로그램 감지 방식 다름
- 키보드 단축키 OS별 차이

### 8.4 사용자 경험
- 오버레이가 작업 방해하지 않도록
- 설정 변경 즉시 반영
- 명확한 에러 메시지
- 데이터 손실 방지 (자동 저장)

---

## 9. 추가 고려사항

### 9.1 향후 확장 기능
- 클라우드 동기화 (선택)
- 팀 기능
- 모바일 앱 연동
- AI 분석 리포트
- 다국어 지원

### 9.2 수익 모델 (선택)
- 무료 버전: 기본 기능
- 프로 버전: 고급 통계, 클라우드 동기화
- 테마 마켓플레이스

### 9.3 배포 채널
- GitHub Releases
- 자체 웹사이트
- Microsoft Store (선택)
- Mac App Store (선택)

---

## 10. 개발 체크리스트

### MVP 완료 기준
- [ ] 오버레이 윈도우가 항상 최상위에 표시
- [ ] 프로그램 감지로 상태 자동 전환
- [ ] 타이머가 정확하게 동작
- [ ] 프로젝트 생성 및 프로그램 매핑
- [ ] 작업 로그 저장
- [ ] 상태별 이미지 변경
- [ ] 기본 통계 조회
- [ ] 설정 저장 및 불러오기
- [ ] 트레이 아이콘 기본 기능
- [ ] Windows, macOS 빌드 가능

이 기획서를 바탕으로 단계별로 개발을 진행하면 체계적으로 프로젝트를 완성할 수 있습니다.